\documentclass{article}

\usepackage{datetime}
% for the current date

\usepackage{amsmath}
% for more advanced math equations

\usepackage{parskip}
% enter a vertical space between paragraphs and skip the indentation

\usepackage{tikz}
\usepackage{tikz-qtree}
% sudo dnf install texlive-tikz-qtree

\usepackage{polyglossia}
\setdefaultlanguage[variant=modern]{greek}
\setotherlanguage{english}
\newfontfamily\greekfont{Linux Libertine}
\newfontfamily\greekfonttt{Inconsolata}
\newfontfamily\englishfont{Linux Libertine}
\newfontfamily\englishfonttt{Inconsolata}
% Noto Serif has to be installed beforehand
% Noto Mono has to be installed beforehand

\DeclareMathOperator*{\argmax}{argmax}
% declase the math operator argmax which can also have a subscript

\title{Επίλυση του Knapsack Problem\\με Χρήση Γενετικού Αλγορίθμου}
\date{\today}
\author{Γκαντίδης Χρήστος 56483}

\begin{document}
\pagenumbering{gobble}
% don't number first page
\maketitle
\newpage

\tableofcontents
\newpage

\pagenumbering{arabic}

\section{Introduction}

Το Knapsack Problem είναι ένα πρόβλημα εύρεσης του βέλτιστου συνδυασμού: Έχοντας
ένα σύνολο πακέτων, το καθένα από τα οποία έχει μια αξία και ένα μέγεθος, βρες
τον συνδυασμό των πακέτων που πρέπει να επιλεγούν, ώστε να μεγιστοποιείται η
συνολική τους αξία, υπό την προϋπόθεση ότι το συνολικό μέγεθος των πακέτων δεν
ξεπερνάει το μέγεθος του σακιδίου μέσα στο οποίο θα τοποθετηθούν τα πακέτα.

Το πρόβλημα αυτό αναφέρεται επίσης και ως 0-1 Knapsack Problem καθώς το κάθε
πακέτο είτε θα βρίσκεται μέσα στο σακίδιο είτε όχι. Επίσης το κάθε πακέτο δεν
μπορεί να σπάσει σε μικρότερα κομμάτια και δεν μπορεί να τοποθετηθεί πάνω από
μία φορά στο σακίδιο.

Σε μαθηματική μορφή το πρόβλημα μπορεί να εκφραστεί και ως:
\begin{align*}
    &\argmax_{S}\left(\sum_{p \in S}\textit{value}(p)\right)\\
    \text{έτσι ώστε } &\sum_{p \in S}\textit{size}(p) \leq \textit{knapsackLimit}
\end{align*}

\section{Bruteforce}

Μια πρώτη σκέψη για την επίλυση του προβλήματος, θα ήταν να πάρουμε όλους τους
πιθανούς συνδυασμούς με τους οποίους μπορούμε να επιλέξουμε ένα σύνολο $S$ από
πακέτα, από $\textit{numPackets}$ συνολικά πακέτα.

Μιας και κάθε πακέτο $p$ είτε θα ανήκει είτε όχι στο σύνολο $S$ (0-1), είναι
φανερό πως υπάρχουν $2^{\textit{numPackets}}$ τέτοιοι συνδυασμοί. Από αυτούς
τους συνδυασμούς κρατάμε μόνο αυτούς οι οποίοι δεν ξεπερνούν σε συνολικό μέγεθος
το μέγεθος του σακιδίου \textit{knapsackLimit}, και έπειτα βρίσκουμε τον
συνδυασμό με την μέγιστη συνολική αξία.

Βλέπουμε λοιπόν πως η πολυπλοκότητα αυτού του αλγορίθμου και σε υπολογισμούς και
σε μνήμη είναι $\mathcal{O}\left(2^{\textit{numPackets}}\right)$, αυξάνεται
δηλαδή εκθετικά με το πλήθος των πακέτων.

\section{Dynamic Programing}

Η επόμενη σκέψη είναι μήπως μπορούμε να βρούμε την βέλτιστη λύση με μικρότερη
πολυπλοκότητα από την εκθετική, και εδώ έρχεται για βοήθεια ο Δυναμικός
Προγραμματισμός.

Ας θεωρήσουμε πως το σύνολο $S$ αποτελεί την βέλτιστη λύση από ένα πλήθος $n$
πακέτων. Τότε, κάθε ένα από τα $n$ πακέτα μπορεί να βρίσκεται σε δύο
καταστάσεις: είτε θα ανήκει στο $S$ είτε όχι. Έτσι η μέγιστη αξία των $n$
πακέτων σε ένα σακίδιο μεγέθους $W$, είναι το μέγιστο από τις ακόλουθες δύο
αξίες:

\begin{enumerate}
    \item Η μέγιστη αξία που μπορεί να βρεθεί για $n-1$ πακέτα σε ένα σακίδιο
            μεγέθους $W$ (δηλαδή το $n$ πακέτο δεν ανήκει στο $S$)
    \item Η μέγιστη αξία που μπορεί να βρεθεί για $n-1$ πακέτα σε ένα σακίδιο
            μεγέθους $W-\textit{size}(n)$ (δηλαδή το $n$ πακέτο ανήκει στο $S$)
\end{enumerate}

Βλέπουμε λοιπόν πως προκύπτει μια αναδρομική σχέση από την οποία μπορούμε να
βρούμε την μέγιστη αξία για ένα πλήθος $n$ πακέτων και ένα σακίδιο μεγέθους $W$.

\begin{sloppypar}
Έστω ότι έχουμε αριθμό πακέτων $\textit{numPackets}=3$ με βάρη πακέτων
$\textit{weights}[]=\{1, 1, 1\}$ και μέγεθος σακιδίου
$\textit{knapsackLimit}=2$. Έστω επίσης $K(n, W)$ η παραπάνω αναδρομική
συνάρτηση, η οποία δέχεται ως είσοδο τον αριθμό του πακέτου προς εκτίμηση $n$,
και το εναπομείναν μέγεθος μέσα στο σακίδιο $W$.
\end{sloppypar}

Κατά την εκτέλεση της συνάρτησης $K$ προκύπτει το ακόλουθο δυαδικό δέντρο, όπου
κάθε αριστερός κλάδος σημαίνει πως το $n$ πακέτο δεν ανήκει στο $S$, ενώ
κάθε δεξιός κλάδος σημαίνει πως το $n$ πακέτο ανήκει στο $S$.

\begin{center}
    \begin{tikzpicture}
    \Tree   [.K(3,2) [.K(2,2) [.K(1,2) [.K(0,2) ] [.K(0,1) ] ] [.K(1,1) [.K(0,1) ] [.K(0,0) ] ] ] [.K(2,1) [.K(1,1) [.K(0,1) ] [.K(0,0) ] ] K(1,0) ] ]
    \end{tikzpicture}
\end{center}

Διαπιστώνουμε πως κάποια υπο-δέντρα επαναλαμβάνονται, άρα αν χρησιμοποιήσουμε
Δυναμικό Προγραμματισμό ώστε να αποθηκεύουμε την τιμή που επιστρέφει η συνάρτηση
για την συγκεκριμένη είσοδο, δεν χρειάζεται να την υπολογίσουμε ξανά.

\begin{sloppypar}
Αν αντί για την συνάρτηση $K$ χρησιμοποιήσουμε έναν πίνακα με διαστάσεις
$\left[\allowbreak \textit{numPackets}+1 \times \textit{knapsackLimit}+1\right]$
όπου στην γραμμή $i$ και στην στήλη $j$ αποθηκεύουμε την βέλτιστη τιμή που
μπορεί να βρεθεί, εξαρτώμενη από το $i$ πακέτο με $j$ εναπομείναντα χώρο στο
σακίδιο, μπορούμε να λύσουμε το πρόβλημα με πολυπλοκότητα και σε υπολογισμούς
και σε μνήμη $\mathcal{O}\left(\textit{numPackets} \cdot
\textit{knapsackLimit}\right)$.
\end{sloppypar}

\begin{sloppypar}
Αν και πλέον το πρόβλημα λύνεται σε πολυωνυμικό χρόνο, η πολυπλοκότητα εξαρτάται
πλέον από το μέγεθος του σακιδίου, το οποίο μπορεί να αποτελέσει πρόβλημα στην
περίπτωση που έχουμε να λύσουμε ένα πολύ εύκολο πρόβλημα, για παράδειγμα με
αριθμό πακέτων $\textit{numPackets} = 1$ και μέγεθος σακιδίου
$\textit{knapsackLimit} = 1000000$. Σε αυτό το παράδειγμα, η bruteforce
προσέγγιση θα υπολόγιζε την βέλτιστη λύση σε 2 βήματα ενώ ο αλγόριθμος με
Δυναμικό Προγραμματισμό σε 1000000 βήματα.
\end{sloppypar}

\section{Genetic Algorithm}

Την λύση έρχεται να μας δώσει η χρήση Γενετικών Αλγορίθμων.

Ο Γενετικός Αλγόριθμος που χρησιμοποιούμε χρησιμοποιεί οντότητες που η κάθε μία
αναπαρίσταται ως ένα δυαδικό διάνυσμα μήκους \textit{numPackets}. Είναι δυαδικό
καθώς σε κάθε θέση $i$ του διανύσματος έχουμε 1 ή 0 που αντιπροσωπεύει την
συμμετοχή ή όχι αντίστοιχα του $i$ πακέτου σε αυτήν την οντότητα.

Κάθε οντότητα αποτελεί μια πιθανή λύση του προβλήματος και σκοπός του γενετικού
αλγορίθμου είναι να εντοπίσει την οντότητα που παράγει την μέγιστη δυνατή
συνολική αξία.

\subsection{Creation Function}

Για την δημιουργία του αρχικού πληθυσμού του προβλήματος χρησιμοποιείται η
συνάρτηση \textit{knapsackCreationFcn}.

Οι πρώτες $\textit{numPackets}$ οντότητες αρχικοποιούνται ως ένας μοναδιαίος
πίνακας διαστάσεων $\left[\textit{numPackets} \times \textit{numPackets}\right]$
κάνοντας έτσι την $i$ οντότητα να περιλαμβάνει μόνο το $i$ πακέτο. Έτσι είμαστε
σίγουροι πως ακόμη κι αν χωράει μόνο ένα πακέτο μέσα στο σακίδιο έχουμε μια
οντότητα η οποία θα ικανοποιεί αυτήν την συνθήκη.

Οι υπόλοιπες οντότητες παράγονται τυχαία ακολουθώντας ομοιόμορφη κατανομή, έτσι
ώστε σε περίπτωση που το σακίδιο χωράει πολλά πακέτα, να έχουμε οντότητες οι
οποίες κατά μέσο όρο περιλαμβάνουν τα μισά πακέτα. Έτσι έχουμε καλύψει και τις
δύο περιπτώσεις: και μικρό και μεγάλο σακίδιο.

\subsection{Mutation Function}

\begin{sloppypar}
Για την μετάλλαξη του πληθυσμού χρησιμοποιείται η συνάρτηση του MATLAB
\textit{mutationuniform}, η οποία για κάθε οντότητα του πληθυσμού, επιλέγει ένα
ποσοστό των γονιδίων της οντότητας, και με πιθανότητα 0.01 αλλάζει την τιμή σε 0
ή 1, χωρίς να λαμβάνει υπόψη την τωρινή τιμή του γονιδίου.
\end{sloppypar}

\subsection{Crossover Function}

Για την αναπαραγωγή των οντοτήτων του πληθυσμού χρησιμοποιείται η συνάρτηση του
MATLAB \textit{crossoverscattered}, η οποία παράγει μια τυχαία δυαδική μάσκα,
και παράγει 2 απογόνους για κάθε 2 γονείς. Ο πρώτος απόγονος έχει τα γονίδια του
πρώτου γονέα στις θέσεις που η μάσκα έχει την τιμή 1 και τα γονίδια του δεύτερου
γονέα στις θέσεις που η μάσκα έχει την τιμή 0. Ο δεύτερος απόγονος παράγεται
χρησιμοποιώντας την αντίθετη μάσκα.

\subsection{Fitness Function}

Για την κατάταξη των οντοτήτων χρησιμοποιείται η συνάρτηση
\textit{knapsackFitnessFcn}, η οποία επιστρέφει ως σκορ της κάθε οντότητας το
αντίθετο του αθροίσματος των αξιών, των πακέτων που είναι ενεργά σε αυτήν την
οντότητα. Ο λόγος που χρησιμοποιείται το αντίθετο του αθροίσματος των αξιών και
όχι το ίδιο το άθροισμα, είναι γιατί ο γενετικός αλγόριθμος προσπαθεί να
ελαχιστοποιήσει την Fitness Function, οπότε κάνοντας το άθροισμα αρνητικό θα
βρούμε την λύση με την πιο αρνητική συνολική αξία, η οποία όμως θα είναι η
μέγιστη κατά απόλυτη τιμή.

\subsection{Conclusion}

Αν και ο Γενετικός Αλγόριθμος δεν συγκλίνει ντετερμινιστικά στην βέλτιστη λύση,
είναι κατάληλος για περιπτώσεις που το μέγεθος του σακιδίου είναι πολύ μεγάλο, ή
για περιπτώσεις που μια καλή προσέγγιση της βέλτιστης λύσης είναι αρκετή.

\end{document}
